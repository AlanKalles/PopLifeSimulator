# 鼠标自动检测楼层建造系统 - 技术计划

**项目**: Pop Life Simulator
**版本**: v1.0
**创建日期**: 2025-10-11
**状态**: 待实施

---

## ⚠️ 重要提示

**每次执行任何阶段或任务时，必须同步更新《鼠标自动检测楼层建造系统-实施日志.md》**

日志更新要求：
- 开始任务前：记录任务开始时间、负责人
- 完成任务后：记录完成时间、实施结果、遇到的问题
- 测试结果：记录测试用例通过情况
- 代码位置：记录修改的文件和行号

---

## 一、需求概述

### 1.1 当前问题
- 用户需要先按Tab/数字键选择楼层
- 再移动鼠标定位网格位置
- 两步操作，认知负担高

### 1.2 改造目标
- ✅ 点击建造按钮 → 进入预览模式
- ✅ 鼠标移动到任意楼层 → 自动在该楼层显示网格预览
- ✅ 点击确认 → 在当前鼠标所在楼层放置建筑
- ✅ **无需手动切换楼层**
- ✅ **Place模式和Move模式都支持自动检测**

### 1.3 设计约束
- ❌ **不支持建筑物旋转功能**（已从系统中移除）
- ✅ **Move模式必须支持自动楼层检测**
- ✅ 保持与现有系统的兼容性

---

## 二、技术架构

### 2.1 系统分层

```
┌─────────────────────────────────────────────┐
│         鼠标输入 (Mouse Input)               │
└──────────────────┬──────────────────────────┘
                   │
         ┌─────────▼─────────┐
         │ FloorDetector     │  ← 新增服务
         │ (每帧检测楼层)     │
         └─────────┬─────────┘
                   │
         ┌─────────▼─────────┐
         │ FloorManager      │  ← 扩展接口
         │ (管理楼层切换)     │
         └─────────┬─────────┘
                   │
         ┌─────────▼─────────┐
         │ ConstructionMgr   │  ← 核心改造
         │ (Place & Move)    │
         └───────────────────┘
```

### 2.2 核心改动点

| 组件 | 改动类型 | 改动内容 |
|------|---------|---------|
| **FloorDetectionService** | 新增 | 鼠标楼层检测服务 |
| **FloorGrid** | 扩展 | 添加检测碰撞体 |
| **FloorManager** | 扩展 | 程序化切换接口 |
| **ConstructionManager** | 改造 | Place和Move模式自动检测 |

---

## 三、分阶段实施计划

### 阶段1：楼层检测系统搭建

#### 任务1.1：为FloorGrid添加检测碰撞体 ⏱️ 预计1小时

**📋 实施前检查清单**
- [ ] 备份 `FloorGrid.cs` 文件
- [ ] 在ProjectSettings中创建 `FloorDetection` Layer（ID: 31）
- [ ] 配置Layer Collision Matrix

**📝 实施步骤**

1. **修改文件**: `Assets/Scripts/Runtime/FloorGrid.cs`

2. **在初始化方法中添加Collider**（`Start()` 或 `Awake()`）：
   ```csharp
   private void InitializeFloorDetection()
   {
       // 检查是否已有BoxCollider2D
       BoxCollider2D collider = GetComponent<BoxCollider2D>();
       if (collider == null) {
           collider = gameObject.AddComponent<BoxCollider2D>();
       }

       // 配置Collider
       collider.isTrigger = true;

       // 计算Collider大小
       Vector2 gridSize = new Vector2(
           gridWidth * cellSize,
           gridHeight * cellSize
       );
       collider.size = gridSize;

       // 计算中心点（考虑originOffset）
       Vector2 center = new Vector2(
           gridSize.x / 2f,
           gridSize.y / 2f
       ) + originOffset;
       collider.offset = center;

       // 设置专用Layer
       gameObject.layer = LayerMask.NameToLayer("FloorDetection");
   }
   ```

3. **在现有初始化流程中调用**：
   ```csharp
   private void Start() {
       // ... 现有代码
       InitializeFloorDetection();
   }
   ```

**✅ 验收标准**
- [ ] 每个FloorGrid自动添加BoxCollider2D
- [ ] Collider大小与网格尺寸匹配
- [ ] Layer正确设置为 `FloorDetection`
- [ ] isTrigger = true
- [ ] Scene视图中Collider可见（绿色边框）

**📌 记录要求**: 完成后在日志中记录修改的代码行号

---

#### 任务1.2：创建楼层检测服务 ⏱️ 预计2小时

**📋 实施前检查清单**
- [ ] 确认 `Assets/Scripts/Services/` 目录存在（不存在则创建）
- [ ] 确认FloorGrid的Collider已正确配置

**📝 实施步骤**

1. **创建文件**: `Assets/Scripts/Services/FloorDetectionService.cs`

2. **命名空间**: `PopLife.Services`

3. **核心接口设计**:
   ```csharp
   public class FloorDetectionService
   {
       // === 配置 ===
       private readonly int detectionInterval;  // 检测间隔（帧）
       private readonly Camera targetCamera;    // 目标相机
       private readonly LayerMask floorLayer;   // 楼层Layer

       // === 缓存 ===
       private FloorGrid cachedFloor;           // 上一帧检测结果
       private int frameCounter;                // 帧计数器

       // === 构造函数 ===
       public FloorDetectionService(
           Camera camera,
           int interval = 3
       ) {
           targetCamera = camera;
           detectionInterval = interval;
           floorLayer = LayerMask.GetMask("FloorDetection");
       }

       // === 核心方法 ===
       public FloorGrid DetectFloorAtMouse();

       // === 辅助方法 ===
       private Vector2 GetMouseWorldPosition();
       private FloorGrid RaycastFloor(Vector2 worldPos);
   }
   ```

4. **实现 `GetMouseWorldPosition()`**:
   ```csharp
   private Vector2 GetMouseWorldPosition()
   {
       Vector3 mousePos = Input.mousePosition;
       mousePos.z = 0f;
       Vector2 worldPos = targetCamera.ScreenToWorldPoint(mousePos);
       return worldPos;
   }
   ```

5. **实现 `RaycastFloor()`**:
   ```csharp
   private FloorGrid RaycastFloor(Vector2 worldPos)
   {
       // 使用零距离射线（点检测）
       RaycastHit2D hit = Physics2D.Raycast(
           worldPos,
           Vector2.zero,
           0f,
           floorLayer
       );

       if (hit.collider != null) {
           return hit.collider.GetComponent<FloorGrid>();
       }

       return null;
   }
   ```

6. **实现 `DetectFloorAtMouse()`**（含性能优化）:
   ```csharp
   public FloorGrid DetectFloorAtMouse()
   {
       // 间隔帧检测（性能优化）
       frameCounter++;
       if (frameCounter < detectionInterval) {
           return cachedFloor;
       }
       frameCounter = 0;

       // 检查鼠标是否在UI上
       if (UnityEngine.EventSystems.EventSystem.current != null &&
           UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject()) {
           cachedFloor = null;
           return null;
       }

       // 执行检测
       Vector2 mousePos = GetMouseWorldPosition();
       FloorGrid detected = RaycastFloor(mousePos);

       cachedFloor = detected;
       return detected;
   }
   ```

**✅ 验收标准**
- [ ] 文件成功创建，无编译错误
- [ ] 鼠标在楼层上返回正确的FloorGrid
- [ ] 鼠标不在楼层上返回null
- [ ] 鼠标在UI上返回null
- [ ] 间隔帧检测正常工作

**📌 记录要求**: 完成后在日志中记录文件路径和核心方法

---

### 阶段2：FloorManager扩展

#### 任务2.1：增加程序化切换接口 ⏱️ 预计1小时

**📋 实施前检查清单**
- [ ] 备份 `FloorManager.cs` 文件
- [ ] 了解当前的 `ActiveFloor` 切换逻辑

**📝 实施步骤**

1. **修改文件**: `Assets/Scripts/Manager/FloorManager.cs`

2. **新增事件定义**（类顶部）:
   ```csharp
   public event Action<FloorGrid> OnActiveFloorChanged;
   ```

3. **新增公共方法**:
   ```csharp
   /// <summary>
   /// 程序化切换到指定楼层（由检测系统调用）
   /// </summary>
   /// <param name="targetFloor">目标楼层，null表示取消激活</param>
   public void SetActiveFloorProgrammatic(FloorGrid targetFloor)
   {
       // 避免重复切换
       if (targetFloor == currentActiveFloor) {
           return;
       }

       // 停用旧楼层
       if (currentActiveFloor != null) {
           currentActiveFloor.SetActive(false);
           // 可选：移除视觉高亮
           SetFloorHighlight(currentActiveFloor, false);
       }

       // 激活新楼层
       currentActiveFloor = targetFloor;
       if (targetFloor != null) {
           targetFloor.SetActive(true);
           // 可选：添加视觉高亮
           SetFloorHighlight(targetFloor, true);
       }

       // 触发事件
       OnActiveFloorChanged?.Invoke(targetFloor);
   }
   ```

4. **可选：视觉高亮方法**:
   ```csharp
   private void SetFloorHighlight(FloorGrid floor, bool enabled)
   {
       SpriteRenderer sr = floor.GetComponent<SpriteRenderer>();
       if (sr == null) {
           sr = floor.gameObject.AddComponent<SpriteRenderer>();
           sr.sortingOrder = -100;  // 确保在最底层
       }

       if (enabled) {
           sr.color = new Color(0.5f, 0.8f, 1f, 0.3f);  // 淡蓝色高亮
       } else {
           sr.color = new Color(1f, 1f, 1f, 0.05f);     // 几乎透明
       }
   }
   ```

**✅ 验收标准**
- [ ] `SetActiveFloorProgrammatic()` 方法可正常调用
- [ ] 切换楼层时触发 `OnActiveFloorChanged` 事件
- [ ] 可选：视觉高亮正常显示
- [ ] 原有Tab键功能不受影响（可选保留）

**📌 记录要求**: 完成后在日志中记录新增的公共接口

---

### 阶段3：ConstructionManager核心改造

#### 任务3.1：集成楼层检测服务 ⏱️ 预计30分钟

**📋 实施前检查清单**
- [ ] 备份 `ConstructionManager.cs` 文件
- [ ] 确认FloorDetectionService已实现

**📝 实施步骤**

1. **修改文件**: `Assets/Scripts/Runtime/ConstructionManager.cs`

2. **新增字段**（类顶部）:
   ```csharp
   // === 楼层检测 ===
   private FloorDetectionService floorDetector;
   private FloorGrid currentDetectedFloor;  // 当前检测到的楼层
   private FloorGrid lastPreviewFloor;      // 上一次预览所在楼层
   ```

3. **在初始化方法中创建检测服务**（`Start()` 或 `Awake()`）:
   ```csharp
   private void Start()
   {
       // ... 现有代码

       // 初始化楼层检测服务
       floorDetector = new FloorDetectionService(
           Camera.main,
           detectionInterval: 3  // 每3帧检测一次
       );
   }
   ```

**✅ 验收标准**
- [ ] FloorDetectionService成功实例化
- [ ] 无编译错误

**📌 记录要求**: 完成后在日志中记录集成位置

---

#### 任务3.2：改造Place模式的Update逻辑 ⏱️ 预计2小时

**📋 实施前检查清单**
- [ ] 理解当前的Place模式流程
- [ ] 确认FloorManager的 `SetActiveFloorProgrammatic()` 可用

**📝 实施步骤**

1. **定位现有的Place模式逻辑**（在 `Update()` 方法中）

2. **重构Update()中的Place模式分支**:

**旧逻辑**（伪代码）:
```csharp
if (mode == ConstructionMode.Place) {
    UpdatePreviewPosition();  // 基于当前选中楼层
    HandlePlaceInput();
}
```

**新逻辑**（伪代码）:
```csharp
if (mode == ConstructionMode.Place) {
    // 1. 检测鼠标所在楼层
    currentDetectedFloor = floorDetector.DetectFloorAtMouse();

    // 2. 楼层变化时切换预览
    if (currentDetectedFloor != lastPreviewFloor) {
        SwitchPreviewFloor(currentDetectedFloor);
        lastPreviewFloor = currentDetectedFloor;
    }

    // 3. 更新预览位置
    if (currentDetectedFloor != null) {
        UpdatePreviewPosition(currentDetectedFloor);
    } else {
        HidePreview();
    }

    // 4. 处理放置输入
    if (currentDetectedFloor != null) {
        HandlePlaceInput(currentDetectedFloor);
    }
}
```

3. **实现 `SwitchPreviewFloor()` 方法**:
   ```csharp
   private void SwitchPreviewFloor(FloorGrid newFloor)
   {
       // 1. 清理旧预览
       if (previewInstance != null) {
           Destroy(previewInstance);
           previewInstance = null;
       }

       // 2. 如果新楼层为null（鼠标离开所有楼层）
       if (newFloor == null) {
           return;
       }

       // 3. 切换FloorManager的当前楼层
       FloorManager.Instance.SetActiveFloorProgrammatic(newFloor);

       // 4. 重新创建预览对象
       CreatePreviewInstance();  // 调用现有方法或实现新方法
   }
   ```

4. **修改 `UpdatePreviewPosition()` 方法签名**:

**旧方法**:
```csharp
private void UpdatePreviewPosition()
{
    FloorGrid floor = FloorManager.Instance.ActiveFloor;
    // ... 基于ActiveFloor的逻辑
}
```

**新方法**:
```csharp
private void UpdatePreviewPosition(FloorGrid targetFloor)
{
    // 直接使用传入的targetFloor
    Vector2Int gridPos = GetGridPositionFromMouse(targetFloor);

    // 更新预览位置
    // ...

    // 验证可放置性
    bool canPlace = ValidatePlacement(targetFloor, gridPos);
    UpdatePreviewColor(canPlace);
}
```

5. **实现 `HidePreview()` 方法**:
   ```csharp
   private void HidePreview()
   {
       if (previewInstance != null) {
           // 方案1：设置透明度为0
           var renderers = previewInstance.GetComponentsInChildren<SpriteRenderer>();
           foreach (var sr in renderers) {
               Color c = sr.color;
               c.a = 0f;
               sr.color = c;
           }

           // 方案2：或者直接禁用GameObject
           // previewInstance.SetActive(false);
       }
   }
   ```

6. **修改 `HandlePlaceInput()` 方法**:
   ```csharp
   private void HandlePlaceInput(FloorGrid targetFloor)
   {
       if (Input.GetMouseButtonDown(0)) {  // 左键点击
           Vector2Int gridPos = GetGridPositionFromMouse(targetFloor);

           if (ValidatePlacement(targetFloor, gridPos)) {
               PlaceBuilding(targetFloor, gridPos);
           }
       }
   }
   ```

**✅ 验收标准**
- [ ] Place模式下，鼠标移动到不同楼层，预览自动切换
- [ ] 鼠标离开所有楼层，预览隐藏
- [ ] 点击放置，建筑出现在正确楼层和位置
- [ ] 预览颜色正确（绿色=可建造，红色=不可）

**📌 记录要求**: 完成后在日志中记录修改的方法列表

---

#### 任务3.3：改造Move模式的Update逻辑 ⏱️ 预计2小时

**📋 实施前检查清单**
- [ ] 理解当前的Move模式流程
- [ ] 确认是否支持跨楼层移动

**📝 实施步骤**

1. **定位现有的Move模式逻辑**（在 `Update()` 方法中）

2. **重构Update()中的Move模式分支**:

**新逻辑**（伪代码）:
```csharp
if (mode == ConstructionMode.Move) {
    // 1. 检测鼠标所在楼层
    currentDetectedFloor = floorDetector.DetectFloorAtMouse();

    // 2. 楼层变化时切换预览
    if (currentDetectedFloor != lastPreviewFloor) {
        SwitchMovePreviewFloor(currentDetectedFloor);
        lastPreviewFloor = currentDetectedFloor;
    }

    // 3. 更新预览位置
    if (currentDetectedFloor != null) {
        UpdateMovePreviewPosition(currentDetectedFloor);
    } else {
        HideMovePreview();
    }

    // 4. 处理移动确认输入
    if (currentDetectedFloor != null) {
        HandleMoveInput(currentDetectedFloor);
    }
}
```

3. **实现 `SwitchMovePreviewFloor()` 方法**:
   ```csharp
   private void SwitchMovePreviewFloor(FloorGrid newFloor)
   {
       if (newFloor == null) {
           return;
       }

       // 检查是否跨楼层移动
       bool isCrossFloor = (newFloor != selectedBuilding.ParentFloor);

       // 切换FloorManager的当前楼层
       FloorManager.Instance.SetActiveFloorProgrammatic(newFloor);

       // 更新移动成本显示（跨楼层成本×2）
       if (isCrossFloor) {
           UpdateMoveCostUI(baseCost * 2);
       } else {
           UpdateMoveCostUI(baseCost);
       }
   }
   ```

4. **实现 `UpdateMovePreviewPosition()` 方法**:
   ```csharp
   private void UpdateMovePreviewPosition(FloorGrid targetFloor)
   {
       Vector2Int gridPos = GetGridPositionFromMouse(targetFloor);

       // 检查是否可移动到该位置
       bool canMove = ValidateMove(targetFloor, gridPos);

       // 更新预览外观
       UpdateMovePreviewColor(canMove);

       // 更新预览位置
       if (movePreviewInstance != null) {
           Vector3 worldPos = targetFloor.GridToWorldPosition(gridPos);
           movePreviewInstance.transform.position = worldPos;
       }
   }
   ```

5. **实现 `ValidateMove()` 方法**:
   ```csharp
   private bool ValidateMove(FloorGrid targetFloor, Vector2Int gridPos)
   {
       // 1. 检查网格是否可用（排除自身占用）
       bool gridAvailable = targetFloor.IsCellAvailableForMove(
           gridPos,
           selectedBuilding
       );

       // 2. 检查资源（移动费用）
       bool isCrossFloor = (targetFloor != selectedBuilding.ParentFloor);
       int moveCost = isCrossFloor ? baseCost * 2 : baseCost;
       bool canAfford = ResourceManager.Instance.Money >= moveCost;

       return gridAvailable && canAfford;
   }
   ```

6. **实现 `HandleMoveInput()` 方法**:
   ```csharp
   private void HandleMoveInput(FloorGrid targetFloor)
   {
       if (Input.GetMouseButtonDown(0)) {  // 左键确认移动
           Vector2Int gridPos = GetGridPositionFromMouse(targetFloor);

           if (ValidateMove(targetFloor, gridPos)) {
               ExecuteMove(targetFloor, gridPos);
           }
       }

       if (Input.GetMouseButtonDown(1)) {  // 右键取消
           ExitMoveMode();
       }
   }
   ```

7. **实现 `ExecuteMove()` 方法**:
   ```csharp
   private void ExecuteMove(FloorGrid targetFloor, Vector2Int newGridPos)
   {
       // 1. 计算移动成本
       bool isCrossFloor = (targetFloor != selectedBuilding.ParentFloor);
       int moveCost = isCrossFloor ? baseCost * 2 : baseCost;

       // 2. 从原位置注销
       FloorGrid oldFloor = selectedBuilding.ParentFloor;
       oldFloor.UnregisterBuilding(selectedBuilding);

       // 3. 在新位置注册
       bool success = targetFloor.RegisterBuilding(
           selectedBuilding,
           newGridPos
       );

       if (success) {
           // 4. 扣除费用
           ResourceManager.Instance.SpendMoney(moveCost);

           // 5. 更新建筑引用
           selectedBuilding.ParentFloor = targetFloor;
           selectedBuilding.GridPosition = newGridPos;

           // 6. 更新世界位置
           Vector3 worldPos = targetFloor.GridToWorldPosition(newGridPos);
           selectedBuilding.transform.position = worldPos;

           // 7. 退出Move模式
           ExitMoveMode();
       } else {
           // 回滚：重新注册到原位置
           oldFloor.RegisterBuilding(selectedBuilding, oldGridPos);
           Debug.LogError("移动失败：目标位置不可用");
       }
   }
   ```

**✅ 验收标准**
- [ ] Move模式下，鼠标移动到不同楼层，预览自动切换
- [ ] 同楼层移动费用正确
- [ ] 跨楼层移动费用正确（×2）
- [ ] 移动成功后建筑出现在正确位置
- [ ] 原位置的网格正确释放

**📌 记录要求**: 完成后在日志中记录Move模式的改动详情

---

### 阶段4：视觉反馈优化

#### 任务4.1：当前楼层高亮 ⏱️ 预计1小时

**📝 实施步骤**

1. **在FloorManager的 `SetFloorHighlight()` 方法中实现**（已在任务2.1中提供）

2. **可选：使用专用Sprite**:
   - 在 `Resources/Sprites/` 创建半透明方形Sprite
   - 在FloorGrid上预挂载SpriteRenderer
   - 通过代码控制颜色和透明度

**✅ 验收标准**
- [ ] 当前楼层有明显的视觉高亮（淡蓝色）
- [ ] 非当前楼层几乎不可见或无高亮
- [ ] 高亮不遮挡建筑物（sortingOrder正确）

**📌 记录要求**: 完成后在日志中记录高亮实现方式

---

#### 任务4.2：鼠标不在楼层上的提示 ⏱️ 预计1小时

**📝 实施步骤**

1. **创建UI提示**（在Canvas中）:
   ```
   Canvas
   └─ FloorDetectionTip (Panel)
       └─ Text: "Please move your mouse to a floor area"
   ```

2. **在ConstructionManager中控制显示**:
   ```csharp
   [SerializeField] private GameObject floorDetectionTip;

   private void Update()
   {
       if (mode == ConstructionMode.Place || mode == ConstructionMode.Move) {
           bool showTip = (currentDetectedFloor == null);
           floorDetectionTip.SetActive(showTip);
       }
   }
   ```

**✅ 验收标准**
- [ ] 鼠标离开所有楼层时，提示UI显示
- [ ] 鼠标进入任意楼层时，提示UI隐藏
- [ ] 退出建造模式时，提示UI隐藏

**📌 记录要求**: 完成后在日志中记录UI路径

---

#### 任务4.3：楼层名称显示（可选） ⏱️ 预计30分钟

**📝 实施步骤**

1. **创建UI文本**（在Canvas中）:
   ```
   Canvas
   └─ FloorNameDisplay (Text)
       └─ "Building on: 2F"
   ```

2. **监听楼层切换事件**:
   ```csharp
   private void Start()
   {
       FloorManager.Instance.OnActiveFloorChanged += UpdateFloorNameDisplay;
   }

   private void UpdateFloorNameDisplay(FloorGrid floor)
   {
       if (floor != null) {
           floorNameText.text = $"Building on: {floor.FloorId + 1}F";
       } else {
           floorNameText.text = "";
       }
   }
   ```

**✅ 验收标准**
- [ ] 楼层切换时，名称正确更新
- [ ] 退出建造模式时，名称隐藏

**📌 记录要求**: 可选实现，完成后记录到日志

---

### 阶段5：边界情况处理

#### 任务5.1：UI遮挡检测 ⏱️ 预计30分钟

**📝 实施步骤**

1. **已在FloorDetectionService中实现**（任务1.2）:
   ```csharp
   if (UnityEngine.EventSystems.EventSystem.current != null &&
       UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject()) {
       return null;
   }
   ```

**✅ 验收标准**
- [ ] 鼠标在UI按钮上时，不检测楼层
- [ ] 鼠标在UI面板上时，预览隐藏

**📌 记录要求**: 验证功能正常

---

#### 任务5.2：快速移动鼠标的响应 ⏱️ 预计30分钟

**📝 实施步骤**

1. **调整检测间隔**（在ConstructionManager中）:
   ```csharp
   [SerializeField] private int detectionInterval = 1;  // 改为每帧检测
   ```

2. **性能测试**:
   - 使用Profiler监测Raycast耗时
   - 如果耗时 < 0.1ms，可保持每帧检测
   - 如果耗时 > 0.5ms，恢复间隔帧检测

**✅ 验收标准**
- [ ] 快速移动鼠标，预览跟随流畅
- [ ] 不会跳过中间楼层
- [ ] 帧率无明显下降

**📌 记录要求**: 记录最终选择的检测间隔

---

#### 任务5.3：建造模式退出时的清理 ⏱️ 预计30分钟

**📝 实施步骤**

1. **修改 `ExitPlaceMode()` 方法**:
   ```csharp
   public void ExitPlaceMode()
   {
       // 清理预览
       if (previewInstance != null) {
           Destroy(previewInstance);
           previewInstance = null;
       }

       // 重置检测状态
       currentDetectedFloor = null;
       lastPreviewFloor = null;

       // 隐藏UI提示
       if (floorDetectionTip != null) {
           floorDetectionTip.SetActive(false);
       }

       // 恢复默认楼层（可选）
       // FloorManager.Instance.SetActiveFloorProgrammatic(defaultFloor);

       // 切换模式
       mode = ConstructionMode.None;
   }
   ```

2. **同样修改 `ExitMoveMode()` 方法**

**✅ 验收标准**
- [ ] 退出模式时，所有预览对象正确销毁
- [ ] 退出模式时，UI提示隐藏
- [ ] 无内存泄漏（Profiler验证）

**📌 记录要求**: 记录清理流程

---

### 阶段6：性能优化

#### 任务6.1：Raycast优化 ⏱️ 预计1小时

**📝 实施步骤**

1. **使用RaycastNonAlloc**（在FloorDetectionService中）:
   ```csharp
   private RaycastHit2D[] hitBuffer = new RaycastHit2D[1];

   private FloorGrid RaycastFloor(Vector2 worldPos)
   {
       int hitCount = Physics2D.RaycastNonAlloc(
           worldPos,
           Vector2.zero,
           hitBuffer,
           0f,
           floorLayer
       );

       if (hitCount > 0 && hitBuffer[0].collider != null) {
           return hitBuffer[0].collider.GetComponent<FloorGrid>();
       }

       return null;
   }
   ```

2. **缓存Camera引用**:
   ```csharp
   private Camera cachedCamera;

   public FloorDetectionService(Camera camera, int interval = 3)
   {
       cachedCamera = camera;  // 避免每次访问Camera.main
       // ...
   }
   ```

**✅ 验收标准**
- [ ] Profiler中Raycast耗时 < 0.1ms/帧
- [ ] 无GC.Alloc（使用NonAlloc方法）

**📌 记录要求**: 记录优化前后的性能数据

---

#### 任务6.2：预览对象池（可选） ⏱️ 预计2小时

**📝 实施步骤**

1. **创建对象池类**:
   ```csharp
   public class PreviewObjectPool
   {
       private Queue<GameObject> pool = new Queue<GameObject>();
       private GameObject prefab;

       public GameObject Get();
       public void Return(GameObject obj);
   }
   ```

2. **在ConstructionManager中使用**:
   ```csharp
   private PreviewObjectPool previewPool;

   private void CreatePreviewInstance()
   {
       previewInstance = previewPool.Get();
       // ... 配置预览
   }

   private void SwitchPreviewFloor(FloorGrid newFloor)
   {
       if (previewInstance != null) {
           previewPool.Return(previewInstance);  // 而非Destroy
       }
       // ...
   }
   ```

**✅ 验收标准**
- [ ] 楼层切换时无Instantiate/Destroy调用
- [ ] 内存占用稳定

**📌 记录要求**: 可选实现，完成后记录性能提升

---

## 四、测试计划

### 4.1 功能测试清单

**基础功能** (8项)
- [ ] T1.1: Place模式下，鼠标移动到楼层A，预览正确显示
- [ ] T1.2: 鼠标移动到楼层B，预览自动切换到楼层B
- [ ] T1.3: 鼠标移出所有楼层，预览隐藏
- [ ] T1.4: 鼠标重新进入楼层，预览恢复显示
- [ ] T1.5: 点击放置，建筑出现在正确楼层和网格位置
- [ ] T1.6: 预览颜色正确显示（绿色=可建造，红色=不可）
- [ ] T1.7: Move模式下，同楼层移动功能正常
- [ ] T1.8: Move模式下，跨楼层移动功能正常，费用×2

**边界测试** (6项)
- [ ] T2.1: 快速跨楼层移动鼠标，预览跟随流畅
- [ ] T2.2: 鼠标停留在楼层边界处，预览稳定不闪烁
- [ ] T2.3: 没有可用楼层时的行为（全部禁用）
- [ ] T2.4: 只有一个楼层时的行为（无需切换）
- [ ] T2.5: 鼠标在UI上时，预览隐藏
- [ ] T2.6: 退出建造模式，预览和UI正确清理

**兼容性测试** (4项)
- [ ] T3.1: Tab键功能保留（如果实现）
- [ ] T3.2: 数字键切换楼层（如果保留）
- [ ] T3.3: 其他系统（如顾客寻路）不受影响
- [ ] T3.4: 资源扣费逻辑正确（建造费用、移动费用）

**性能测试** (3项)
- [ ] T4.1: 10个楼层场景下，帧率 > 60fps
- [ ] T4.2: 长时间建造模式（5分钟），无内存泄漏
- [ ] T4.3: Profiler中Raycast耗时 < 0.1ms/帧

### 4.2 测试执行顺序

1. **阶段完成后测试**：每完成一个阶段，执行对应的功能测试
2. **集成测试**：所有阶段完成后，执行完整测试清单
3. **回归测试**：修复bug后，重新执行相关测试用例

### 4.3 测试记录要求

每个测试用例执行后，在日志中记录：
- 测试用例编号（如T1.1）
- 测试结果（通过/失败）
- 失败原因（如果失败）
- 测试时间

---

## 五、风险与注意事项

### 5.1 多相机场景
**风险**: 如果有多个Camera，`Camera.main` 可能不是当前使用的
**解决方案**: 在FloorDetectionService构造函数中注入正确的Camera引用
**优先级**: 🟡 中

### 5.2 UI遮挡
**风险**: 鼠标在UI上时，Raycast可能穿透到楼层
**解决方案**: 已在FloorDetectionService中添加 `IsPointerOverGameObject()` 检查
**优先级**: 🟢 已解决

### 5.3 Move模式兼容性
**决策**: ✅ **Move模式必须支持自动检测楼层**
**实施**: 已在阶段3-任务3.3中详细规划
**优先级**: 🔴 高

### 5.4 性能影响
**风险**: 每帧Raycast可能影响性能
**解决方案**:
- 使用间隔帧检测（默认3帧）
- 使用RaycastNonAlloc减少GC
- 缓存检测结果
**优先级**: 🟡 中

### 5.5 楼层重叠
**风险**: 3D视角下楼层可能在Z轴重叠
**解决方案**: 使用 `Physics2D.RaycastAll` 并选择最近的
**优先级**: 🟢 低（当前为2D游戏）

---

## 六、实施时间线

| 阶段 | 任务 | 预计时间 | 依赖 |
|------|------|---------|------|
| 阶段1 | 任务1.1 | 1小时 | 无 |
| 阶段1 | 任务1.2 | 2小时 | 任务1.1 |
| 阶段2 | 任务2.1 | 1小时 | 无 |
| 阶段3 | 任务3.1 | 0.5小时 | 任务1.2 |
| 阶段3 | 任务3.2 | 2小时 | 任务2.1, 3.1 |
| 阶段3 | 任务3.3 | 2小时 | 任务2.1, 3.1 |
| 阶段4 | 任务4.1-4.3 | 2.5小时 | 阶段3完成 |
| 阶段5 | 任务5.1-5.3 | 1.5小时 | 阶段3完成 |
| 阶段6 | 任务6.1-6.2 | 3小时 | 所有阶段完成 |
| 测试 | 完整测试 | 3小时 | 所有阶段完成 |
| **总计** | | **18.5小时** | |

### 关键路径
```
任务1.1 → 任务1.2 → 任务3.1 → 任务3.2 → 任务3.3 → 测试
```

---

## 七、代码变更统计

### 新增文件 (1个)
- `Assets/Scripts/Services/FloorDetectionService.cs` (~150行)

### 修改文件 (3个)
- `Assets/Scripts/Runtime/FloorGrid.cs` (+30行)
- `Assets/Scripts/Manager/FloorManager.cs` (+50行)
- `Assets/Scripts/Runtime/ConstructionManager.cs` (+200行)

### ProjectSettings配置
- 新增Layer: `FloorDetection`
- Layer Collision Matrix配置

### 预计总代码量
- 新增代码: ~430行
- 重构代码: ~150行
- 总计: ~580行

---

## 八、验收标准

### 8.1 核心功能验收
✅ Place模式：鼠标自动检测楼层，无需手动切换
✅ Move模式：支持自动检测楼层，跨楼层移动费用正确
✅ 预览跟随：鼠标移动时，预览流畅跟随
✅ 边界处理：鼠标离开楼层时，预览正确隐藏

### 8.2 性能验收
✅ 帧率: 10楼层场景 > 60fps
✅ 内存: 长时间运行无泄漏
✅ Raycast: 耗时 < 0.1ms/帧

### 8.3 兼容性验收
✅ 现有功能不受影响（顾客寻路、资源管理等）
✅ 可选：Tab键功能保留
✅ 代码质量：无编译警告，符合项目规范

---

## 九、后续优化方向

### 9.1 短期优化 (可选)
- [ ] 平滑过渡动画：预览切换楼层时添加淡入淡出
- [ ] 快捷键增强：Ctrl键临时锁定楼层（精细操作）
- [ ] 声音反馈：楼层切换时播放音效

### 9.2 长期优化 (未来版本)
- [ ] 智能楼层推荐：根据建筑类型推荐合适楼层
- [ ] 多楼层同时预览：半透明显示其他楼层网格
- [ ] VFX效果：楼层高亮使用粒子效果

---

## 十、文档维护

### 10.1 文档更新规则
- 每次任务开始前：更新日志文档，记录开始时间
- 每次任务完成后：更新日志文档，记录完成状态和问题
- 遇到计划外问题：在日志中记录问题和解决方案
- 计划变更：在本文档中标注变更，并在日志中说明原因

### 10.2 相关文档
- **实施日志**: `Assets/Documents/鼠标自动检测楼层建造系统-实施日志.md`
- **项目规范**: `CLAUDE.md`

---

## 附录

### A. 关键代码片段索引
- FloorDetectionService核心逻辑: 阶段1-任务1.2
- FloorManager程序化切换: 阶段2-任务2.1
- Place模式改造: 阶段3-任务3.2
- Move模式改造: 阶段3-任务3.3

### B. 调试技巧
1. **检查Raycast**: 在Scene视图中启用Physics Debug显示
2. **检查Collider**: 选中FloorGrid查看BoxCollider2D边界
3. **检查Layer**: 确认GameObject的Layer为 `FloorDetection`
4. **检查事件**: 在FloorManager中打断点，观察事件触发

### C. 常见问题排查
| 问题 | 可能原因 | 解决方案 |
|------|---------|---------|
| 鼠标检测不到楼层 | Layer未设置 | 检查FloorGrid的Layer |
| 预览不切换 | 事件未触发 | 检查FloorManager事件订阅 |
| 性能下降 | 每帧Raycast | 增加检测间隔 |
| 预览闪烁 | 楼层边界重复切换 | 添加切换阈值 |

---

**文档版本**: v1.0
**最后更新**: 2025-10-11
**下次审查**: 实施完成后

---

📌 **重要提醒**: 开始任何任务前，请先阅读对应的实施步骤，并更新实施日志！
