# Building Interaction System Design
## 建筑交互系统设计文档

**Version**: 1.0
**Date**: 2025-10-18
**Author**: Claude Code
**Status**: Design Phase

---

## 1. Overview | 概述

### 1.1 Purpose | 设计目标
In non-construction phases (including both Build Phase when not actively placing buildings, and Open Phase), players can interact with existing buildings (shelves and facilities) through intuitive mouse interactions to view information and manage upgrades.

在非建造操作时（包括建造阶段未选择建造时、以及营业阶段），玩家可通过鼠标交互查看已有建筑物（货架/设施）的信息并进行管理。

### 1.2 Interaction Flow | 交互流程
```
Mouse Hover (鼠标悬停)
  ↓
Outline Highlight (轮廓高亮)
  ↓
Single Click (单击)
  ↓
Info Bubble (信息气泡)
  - Displays for 1.5s
  - Fades out 1.5s~2s
  - Disappears at 2s
  ↓
Click Again Within 2s (2秒内再次点击)
  ↓
Detail Panel (详情面板)
  - Full information
  - Upgrade button (if in Build Phase)
```

---

## 2. Technical Architecture | 技术架构

### 2.1 System Structure | 系统结构
```
Assets/Scripts/UI/BuildingInteraction/
├── BuildingInteractionManager.cs      // Core manager (Singleton)
│   ├── Input detection (Raycast)
│   ├── State management (Hover/Click/DoubleClick)
│   └── Component coordination
│
├── BuildingHighlighter.cs             // Outline highlight controller
│   ├── LineRenderer component
│   ├── Outline calculation
│   └── Show/Hide animations
│
├── BuildingInfoBubble.cs              // Info bubble UI (World Space Canvas)
│   ├── Display: Name, Level, Stock
│   ├── Fade animations (DOTween)
│   └── Object pooling
│
└── BuildingDetailPanel.cs             // Detail panel UI (Screen Space Canvas)
    ├── Full information display
    ├── Upgrade logic
    └── Phase-based button state
```

### 2.2 Technology Stack | 技术选型

| Component | Technology | Rationale |
|-----------|-----------|-----------|
| **Outline Highlight** | LineRenderer | Supports irregular shapes, reusable, minimal resource overhead |
| **Bubble UI** | UGUI World Space Canvas | Follows building position, simple fade animations |
| **Detail Panel** | UGUI Screen Space Canvas | Centered display, consistent with existing UI |
| **Input Detection** | Physics2D.Raycast | Direct detection of "interactableShelf" layer |
| **Animation** | DOTween (optional) | Smooth fade effects, easy to control |

---

## 3. Core Features | 核心功能

### 3.1 Outline Highlighting | 轮廓高亮

#### 3.1.1 Implementation Principle | 实现原理
1. Raycast detects BuildingInstance on "interactableShelf" layer
2. Retrieve occupied cells via `archetype.GetRotatedFootprint(rotation)`
3. Convert relative offsets to absolute grid coordinates
4. Calculate outer boundary vertices (remove internal edges)
5. Convert to world coordinates using `FloorGrid.GridToWorld()`
6. Draw outline using LineRenderer

#### 3.1.2 Outline Calculation Algorithm | 轮廓计算算法
```csharp
/// <summary>
/// Calculate outer boundary vertices from occupied cells
/// 从占用格子计算外轮廓顶点
/// </summary>
List<Vector3> CalculateOutlineVertices(BuildingInstance building, FloorGrid floor)
{
    // 1. Get absolute grid positions
    List<Vector2Int> cells = GetAbsoluteCells(building);

    // 2. Build edge set (4 edges per cell)
    HashSet<Edge> edges = new HashSet<Edge>();
    foreach (var cell in cells)
    {
        AddCellEdges(edges, cell);
    }

    // 3. Remove internal shared edges (keep only boundary)
    RemoveInternalEdges(edges, cells);

    // 4. Sort and connect edges into a loop
    List<Vector2Int> gridLoop = ConnectEdgesIntoLoop(edges);

    // 5. Convert to world coordinates
    List<Vector3> worldVertices = new List<Vector3>();
    foreach (var gridPos in gridLoop)
    {
        worldVertices.Add(floor.GridToWorld(gridPos));
    }

    return worldVertices;
}

/// <summary>
/// Get absolute grid positions (building position + rotated footprint)
/// 获取绝对网格坐标（建筑位置 + 旋转后占地）
/// </summary>
List<Vector2Int> GetAbsoluteCells(BuildingInstance building)
{
    List<Vector2Int> relativeCells = building.archetype.GetRotatedFootprint(building.rotation);
    List<Vector2Int> absoluteCells = new List<Vector2Int>();

    foreach (var offset in relativeCells)
    {
        absoluteCells.Add(building.gridPosition + offset);
    }

    return absoluteCells;
}
```

#### 3.1.3 Edge Data Structure | 边数据结构
```csharp
/// <summary>
/// Represents an edge between two grid vertices
/// 表示两个网格顶点之间的边
/// </summary>
struct Edge : IEquatable<Edge>
{
    public Vector2Int start;
    public Vector2Int end;

    public Edge(Vector2Int a, Vector2Int b)
    {
        // Ensure consistent ordering for hash comparison
        if (a.x < b.x || (a.x == b.x && a.y < b.y))
        {
            start = a;
            end = b;
        }
        else
        {
            start = b;
            end = a;
        }
    }

    public bool Equals(Edge other)
    {
        return start == other.start && end == other.end;
    }

    public override int GetHashCode()
    {
        return HashCode.Combine(start, end);
    }
}
```

#### 3.1.4 Visual Effects | 视觉效果
- **Line Color**: Bright cyan/yellow (高亮颜色：亮青色/黄色)
- **Line Width**: 0.1 world units (线宽：0.1世界单位)
- **Material**: Unlit shader with emissive glow (材质：自发光Shader)
- **Z-Order**: Slightly above buildings (Z序：略高于建筑物)

---

### 3.2 Info Bubble | 信息气泡

#### 3.2.1 UI Layout | UI布局
```
┌──────────────────────┐
│  [Icon]  Name Lv.X   │
│  Stock: XX/XX        │  (for Shelves only)
└──────────────────────┘
```

#### 3.2.2 Display Logic | 显示逻辑
```csharp
void ShowBubble(BuildingInstance building)
{
    // Position above building center
    Vector3 worldPos = building.transform.position + Vector3.up * 1.5f;
    bubble.transform.position = worldPos;

    // Populate content
    if (building is ShelfInstance shelf)
    {
        bubbleText.text = $"{shelf.archetype.displayName} Lv.{shelf.currentLevel}\n" +
                          $"Stock: {shelf.currentStock}/{shelf.maxStock}";
    }
    else if (building is FacilityInstance facility)
    {
        bubbleText.text = $"{facility.archetype.displayName} Lv.{facility.currentLevel}";
    }

    // Animation: Fade in -> Hold -> Fade out
    bubble.alpha = 0;
    bubble.DOFade(1, 0.2f).OnComplete(() =>
    {
        // Hold for 1.3s, then fade out
        bubble.DOFade(0, 0.5f).SetDelay(1.3f).OnComplete(() =>
        {
            bubble.gameObject.SetActive(false);
        });
    });
}
```

#### 3.2.3 Animation Timeline | 动画时间轴
```
0s        0.2s              1.5s              2s
│─────────│─────────────────│─────────────────│
  Fade In      Fully Visible    Fade Out    Disappear
  淡入          完全显示         淡出         消失
```

---

### 3.3 Detail Panel | 详情面板

#### 3.3.1 UI Layout | UI布局
```
┌─────────────────────────────────┐
│         Building Details        │
│                                 │
│  [Large Icon]                   │
│                                 │
│  Name:       Lingerie Shelf     │
│  Category:   Lingerie           │
│  Level:      3                  │
│  Price:      $50                │
│  Stock:      25/50              │
│  Attractiveness: 4.5            │
│                                 │
│  [Upgrade] [Close]              │
└─────────────────────────────────┘
```

#### 3.3.2 Upgrade Button Logic | 升级按钮逻辑
```csharp
void UpdateUpgradeButton()
{
    bool canUpgrade = DayLoopManager.Instance.currentPhase == GamePhase.BuildPhase
                   && currentBuilding.currentLevel < currentBuilding.archetype.MaxLevel;

    upgradeButton.interactable = canUpgrade;

    if (DayLoopManager.Instance.currentPhase == GamePhase.OpenPhase)
    {
        upgradeButton.GetComponentInChildren<Text>().text = "Upgrade (Available in Build Phase)";
        upgradeButton.GetComponent<Image>().color = Color.gray;
    }
}

void OnUpgradeClicked()
{
    if (currentBuilding.TryUpgrade())
    {
        RefreshPanel(); // Update display
        ShowUpgradeSuccessEffect();
    }
    else
    {
        ShowUpgradeFailedMessage("Insufficient Fame");
    }
}
```

---

### 3.4 Click Detection | 点击检测

#### 3.4.1 Double-Click Logic | 双击逻辑
```csharp
private BuildingInstance lastClickedBuilding = null;
private float lastClickTime = 0f;
private const float DOUBLE_CLICK_WINDOW = 2f;

void Update()
{
    // Detect mouse click
    if (Input.GetMouseButtonDown(0))
    {
        BuildingInstance clicked = GetBuildingUnderMouse();

        if (clicked != null)
        {
            OnBuildingClicked(clicked);
        }
    }
}

void OnBuildingClicked(BuildingInstance building)
{
    float currentTime = Time.time;

    // Check if double-click (same building within 2s)
    if (lastClickedBuilding == building &&
        currentTime - lastClickTime < DOUBLE_CLICK_WINDOW)
    {
        // Double-click: Show detail panel
        HideBubble();
        ShowDetailPanel(building);
    }
    else
    {
        // Single-click: Show bubble
        ShowBubble(building);
    }

    // Update last click info
    lastClickedBuilding = building;
    lastClickTime = currentTime;
}
```

#### 3.4.2 Raycast Detection | Raycast检测
```csharp
BuildingInstance GetBuildingUnderMouse()
{
    Vector3 mouseWorld = Camera.main.ScreenToWorldPoint(Input.mousePosition);
    RaycastHit2D hit = Physics2D.Raycast(
        mouseWorld,
        Vector2.zero,
        Mathf.Infinity,
        LayerMask.GetMask("interactableShelf")
    );

    if (hit.collider != null)
    {
        return hit.collider.GetComponent<BuildingInstance>();
    }

    return null;
}
```

---

## 4. State Management | 状态管理

### 4.1 Interaction States | 交互状态
```csharp
public enum InteractionState
{
    None,           // No interaction
    Hovering,       // Mouse hovering, showing outline
    BubbleShowing,  // Bubble visible after click
    DetailPanelOpen // Detail panel open
}
```

### 4.2 State Transitions | 状态转换
```
None ←→ Hovering
        ↓
    BubbleShowing ←→ DetailPanelOpen
        ↓
      None (after 2s)
```

### 4.3 State Machine Logic | 状态机逻辑
```csharp
void UpdateState()
{
    switch (currentState)
    {
        case InteractionState.None:
            UpdateNoneState();
            break;

        case InteractionState.Hovering:
            UpdateHoveringState();
            break;

        case InteractionState.BubbleShowing:
            UpdateBubbleState();
            break;

        case InteractionState.DetailPanelOpen:
            UpdateDetailPanelState();
            break;
    }
}

void UpdateHoveringState()
{
    BuildingInstance hovered = GetBuildingUnderMouse();

    if (hovered != currentHoveredBuilding)
    {
        if (currentHoveredBuilding != null)
        {
            highlighter.Hide(); // Hide previous outline
        }

        if (hovered != null)
        {
            highlighter.Show(hovered); // Show new outline
        }

        currentHoveredBuilding = hovered;
    }
}
```

---

## 5. Performance Optimization | 性能优化

### 5.1 Input Detection Optimization | 输入检测优化
```csharp
// Only detect when mouse moves (avoid per-frame raycasts)
private Vector3 lastMousePosition;

void Update()
{
    Vector3 currentMousePos = Input.mousePosition;

    if (currentMousePos != lastMousePosition)
    {
        UpdateHover();
        lastMousePosition = currentMousePos;
    }
}
```

### 5.2 LineRenderer Optimization | LineRenderer优化
- Use single shared LineRenderer instance (复用单个LineRenderer实例)
- Limit vertex count to < 100 (顶点数控制在100以内)
- Use simple Unlit shader (使用简单的Unlit Shader)

### 5.3 UI Object Pooling | UI对象池
```csharp
// Bubble object pool
private Queue<GameObject> bubblePool = new Queue<GameObject>();
private const int POOL_SIZE = 5;

GameObject GetBubbleFromPool()
{
    if (bubblePool.Count > 0)
    {
        GameObject bubble = bubblePool.Dequeue();
        bubble.SetActive(true);
        return bubble;
    }
    else
    {
        return Instantiate(bubblePrefab);
    }
}

void ReturnBubbleToPool(GameObject bubble)
{
    bubble.SetActive(false);
    bubblePool.Enqueue(bubble);
}
```

---

## 6. Edge Cases & Error Handling | 边界情况处理

### 6.1 Construction Mode Active | 建造模式激活
```csharp
bool CanInteract()
{
    // Disable interaction when ConstructionManager is in Place/Move mode
    if (ConstructionManager.Instance.currentMode != ConstructionMode.None)
    {
        return false;
    }
    return true;
}
```

### 6.2 Building Destroyed During Interaction | 交互中建筑被销毁
```csharp
void Update()
{
    if (currentHoveredBuilding != null && currentHoveredBuilding == null) // Destroyed
    {
        highlighter.Hide();
        currentHoveredBuilding = null;
    }

    if (lastClickedBuilding != null && lastClickedBuilding == null) // Destroyed
    {
        HideBubble();
        HideDetailPanel();
        lastClickedBuilding = null;
    }
}
```

### 6.3 Multi-Floor Handling | 多楼层处理
- Raycast automatically detects the correct floor (since buildings have colliders)
- No manual floor switching needed (不需要手动切换楼层)
- Outline draws in world space at building's actual position (轮廓在建筑实际位置的世界空间绘制)

---

## 7. UI/UX Guidelines | UI/UX指南

### 7.1 Visual Feedback | 视觉反馈
- **Outline Color**: Use contrasting color vs. background (高亮颜色需与背景对比明显)
- **Cursor Change**: Change cursor to "pointer" when hovering buildings (悬停时改变鼠标指针)
- **Bubble Position**: Always above building, avoid screen edge clipping (气泡始终在建筑上方，避免超出屏幕)

### 7.2 Accessibility | 可访问性
- **Minimum Font Size**: 14px (最小字体：14像素)
- **Color Blind Safe**: Use shape/icon in addition to color (支持色盲：使用形状/图标辅助颜色)
- **Keyboard Support**: ESC to close detail panel (ESC键关闭详情面板)

### 7.3 Animation Timing | 动画时机
- **Outline Fade**: 0.1s fade in/out (轮廓淡入淡出：0.1秒)
- **Bubble Fade In**: 0.2s (气泡淡入：0.2秒)
- **Bubble Fade Out**: 0.5s (气泡淡出：0.5秒)
- **Panel Fade In**: 0.3s (面板淡入：0.3秒)

---

## 8. Testing Checklist | 测试清单

### 8.1 Functional Tests | 功能测试
- [ ] Outline highlights correctly on hover (悬停时正确高亮)
- [ ] Outline follows irregular building shapes (支持不规则建筑形状)
- [ ] Bubble shows correct info for shelves (货架信息正确)
- [ ] Bubble shows correct info for facilities (设施信息正确)
- [ ] Bubble disappears after 2 seconds (气泡2秒后消失)
- [ ] Double-click opens detail panel (双击打开详情面板)
- [ ] Upgrade button enabled in Build Phase (建造阶段升级按钮可用)
- [ ] Upgrade button disabled in Open Phase (营业阶段升级按钮禁用)
- [ ] Upgrade consumes Fame correctly (升级正确消耗声望)
- [ ] Panel closes when clicking outside (点击外部关闭面板)

### 8.2 Performance Tests | 性能测试
- [ ] Smooth performance with 20+ buildings (20+建筑物时流畅)
- [ ] No GC spikes during interaction (交互时无GC峰值)
- [ ] Outline calculation < 1ms (轮廓计算 < 1毫秒)

### 8.3 Edge Case Tests | 边界测试
- [ ] No interaction during construction mode (建造模式下无交互)
- [ ] Handles building destruction gracefully (建筑销毁时正常处理)
- [ ] Works across multiple floors (多楼层正常工作)
- [ ] Handles rapid clicking (处理快速点击)

---

## 9. Future Enhancements | 未来扩展

### 9.1 Advanced Visual Effects | 高级视觉效果
- Animated outline (flowing/pulsing) (动画轮廓：流动/脉冲)
- Glow effect on hover (悬停时发光效果)
- Particle effects on upgrade (升级时粒子效果)

### 9.2 Additional Features | 附加功能
- Multi-select buildings (Shift+Click) (多选建筑物)
- Batch upgrade (批量升级)
- Building comparison tooltips (建筑对比提示)
- Quick action menu (right-click) (右键快捷菜单)

### 9.3 Accessibility Improvements | 可访问性改进
- Screen reader support (屏幕阅读器支持)
- Customizable hotkeys (自定义快捷键)
- High contrast mode (高对比度模式)

---

## 10. Implementation Priority | 实现优先级

### Phase 1: Core Functionality (MVP)
1. BuildingInteractionManager basic structure
2. Raycast detection
3. BuildingHighlighter with LineRenderer
4. Basic outline calculation
5. Info bubble display
6. Double-click detection
7. Detail panel display

### Phase 2: Polish
1. Fade animations
2. Upgrade button logic
3. Object pooling
4. Performance optimization

### Phase 3: Advanced Features
1. Advanced visual effects
2. Additional interactions
3. Accessibility features

---

## 11. Dependencies | 依赖项

### 11.1 Unity Packages
- Unity UI (UGUI) - Built-in
- Physics2D - Built-in
- DOTween (optional) - For smooth animations

### 11.2 Project Systems
- `BuildingInstance` / `ShelfInstance` / `FacilityInstance`
- `FloorGrid` (GridToWorld conversion)
- `DayLoopManager` (phase detection)
- `ResourceManager` (Fame consumption)
- `ConstructionManager` (mode detection)

### 11.3 Assets Required
- Bubble UI prefab (World Space Canvas)
- Detail panel UI prefab (Screen Space Canvas)
- Outline material (Unlit shader)
- Building icons (for detail panel)

---

## Appendix A: Code Templates | 附录A：代码模板

### A.1 BuildingInteractionManager.cs (Skeleton)
```csharp
using UnityEngine;
using PopLife.Runtime;

namespace PopLife.UI.BuildingInteraction
{
    public class BuildingInteractionManager : MonoBehaviour
    {
        public static BuildingInteractionManager Instance { get; private set; }

        [Header("Components")]
        [SerializeField] private BuildingHighlighter highlighter;
        [SerializeField] private BuildingInfoBubble bubblePrefab;
        [SerializeField] private BuildingDetailPanel detailPanel;

        [Header("Settings")]
        [SerializeField] private LayerMask buildingLayerMask;
        [SerializeField] private float doubleClickWindow = 2f;

        private BuildingInstance currentHoveredBuilding;
        private BuildingInstance lastClickedBuilding;
        private float lastClickTime;
        private Vector3 lastMousePosition;

        private void Awake()
        {
            Instance = this;
        }

        private void Update()
        {
            if (!CanInteract()) return;

            UpdateHoverDetection();
            UpdateClickDetection();
        }

        private bool CanInteract()
        {
            // Check if construction mode is active
            return ConstructionManager.Instance.currentMode == ConstructionMode.None;
        }

        private void UpdateHoverDetection()
        {
            Vector3 currentMousePos = Input.mousePosition;

            if (currentMousePos != lastMousePosition)
            {
                BuildingInstance hovered = GetBuildingUnderMouse();

                if (hovered != currentHoveredBuilding)
                {
                    OnHoveredBuildingChanged(hovered);
                }

                lastMousePosition = currentMousePos;
            }
        }

        private void UpdateClickDetection()
        {
            if (Input.GetMouseButtonDown(0))
            {
                BuildingInstance clicked = GetBuildingUnderMouse();

                if (clicked != null)
                {
                    OnBuildingClicked(clicked);
                }
            }
        }

        private BuildingInstance GetBuildingUnderMouse()
        {
            Vector3 mouseWorld = Camera.main.ScreenToWorldPoint(Input.mousePosition);
            RaycastHit2D hit = Physics2D.Raycast(mouseWorld, Vector2.zero, Mathf.Infinity, buildingLayerMask);

            return hit.collider?.GetComponent<BuildingInstance>();
        }

        private void OnHoveredBuildingChanged(BuildingInstance newHovered)
        {
            if (currentHoveredBuilding != null)
            {
                highlighter.Hide();
            }

            if (newHovered != null)
            {
                highlighter.Show(newHovered);
            }

            currentHoveredBuilding = newHovered;
        }

        private void OnBuildingClicked(BuildingInstance building)
        {
            // TODO: Implement double-click logic
        }
    }
}
```

---

## Document History | 文档历史

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-10-18 | Initial design document | Claude Code |

---

**End of Document**
